#include <iostream>
#include <vector>
#include <cstring>
#include <fstream>
#include <sstream>

using namespace std;

struct Producto {
    int codigo;
    char nombre[30];
    float precio;
    int stock;
    char categoria[30];
    bool activo;
};

vector<Producto> productos;
const char* archivoBinario = "productos.dat";

// Función para leer enteros de forma segura
int leerEntero(const char* mensaje) {
    string linea;
    int valor;
    while (true) {
        cout << mensaje;
        getline(cin, linea);
        stringstream ss(linea);
        if (ss >> valor && ss.eof()) {
            return valor;
        }
        cout << "Ingrese un numero valido.\n";
    }
}

// Función para leer flotantes de forma segura
float leerFloat(const char* mensaje) {
    string linea;
    float valor;
    while (true) {
        cout << mensaje;
        getline(cin, linea);
        stringstream ss(linea);
        if (ss >> valor && ss.eof()) {
            return valor;
        }
        cout << "Ingrese un numero valido.\n";
    }
}

void agregarProducto() {
    Producto p;
    
    p.codigo = leerEntero("Codigo: ");
    
    // Verificar código duplicado
    for (int i = 0; i < productos.size(); i++) {
        if (productos[i].codigo == p.codigo) {
            cout << "Error: Codigo ya existe.\n";
            return;
        }
    }
    
    cout << "Nombre: ";
    cin.getline(p.nombre, 30);
    p.precio = leerFloat("Precio($): ");
    p.stock = leerEntero("Stock: ");
    cout << "Categoria: ";
    cin.getline(p.categoria, 30);
    p.activo = true;
    
    productos.push_back(p);
    cout << "Producto agregado.\n";
}

void mostrarProductosActivos() {
    bool hay = false;
    for (int i = 0; i < productos.size(); i++) {
        if (productos[i].activo) {
            cout << "Codigo: " << productos[i].codigo << ", Nombre: " << productos[i].nombre
                 << ", Precio: $" << productos[i].precio << ", Stock: " << productos[i].stock
                 << ", Categoria: " << productos[i].categoria << endl;
            hay = true;
        }
    }
    if (!hay) cout << "No hay productos activos.\n";
}

void mostrarPorCategoria() {
    char cat[30];
    cout << "Categoria: ";
    cin.getline(cat, 30);
    
    bool encontrado = false;
    for (int i = 0; i < productos.size(); i++) {
        if (productos[i].activo && strcmp(productos[i].categoria, cat) == 0) {
            cout << "Codigo: " << productos[i].codigo << ", Nombre: " << productos[i].nombre
                 << ", Precio: $" << productos[i].precio << ", Stock: " << productos[i].stock << endl;
            encontrado = true;
        }
    }
    if (!encontrado) cout << "No se encontraron productos.\n";
}

void buscarPorCodigo() {
    int codigo = leerEntero("Codigo a buscar: ");
    
    for (int i = 0; i < productos.size(); i++) {
        if (productos[i].codigo == codigo) {
            cout << "Codigo: " << productos[i].codigo << ", Nombre: " << productos[i].nombre
                 << ", Precio: $" << productos[i].precio << ", Stock: " << productos[i].stock
                 << ", Categoria: " << productos[i].categoria << endl;
            return;
        }
    }
    cout << "Producto no encontrado.\n";
}

void modificarProducto() {
    int codigo = leerEntero("Codigo a modificar: ");
    
    for (int i = 0; i < productos.size(); i++) {
        if (productos[i].codigo == codigo) {
            cout << "Producto encontrado.\n";
            productos[i].precio = leerFloat("Nuevo precio($): ");
            productos[i].stock = leerEntero("Nuevo stock: ");
            cout << "Nueva categoria: ";
            cin.getline(productos[i].categoria, 30);
            cout << "Producto modificado.\n";
            return;
        }
    }
    cout << "Producto no encontrado.\n";
}

void eliminarProducto() {
    int codigo = leerEntero("Codigo a eliminar: ");
    
    for (int i = 0; i < productos.size(); i++) {
        if (productos[i].codigo == codigo) {
            productos[i].activo = false;
            cout << "Producto eliminado.\n";
            return;
        }
    }
    cout << "Producto no encontrado.\n";
}

void cargarDatos() {
    ifstream archivo(archivoBinario, ios::binary);
    if (!archivo) {
        cout << "No se pudo abrir el archivo.\n";
        return;
    }
    
    productos.clear();
    Producto p;
    while (archivo.read(reinterpret_cast<char*>(&p), sizeof(Producto))) {
        productos.push_back(p);
    }
    archivo.close();
    cout << "Datos cargados: " << productos.size() << " productos.\n";
}

void guardarDatos() {
    ofstream archivo(archivoBinario, ios::binary);
    if (!archivo) {
        cout << "No se pudo abrir el archivo.\n";
        return;
    }
    
    for (int i = 0; i < productos.size(); i++) {
        archivo.write(reinterpret_cast<const char*>(&productos[i]), sizeof(Producto));
    }
    archivo.close();
    cout << "Datos guardados.\n";
}

int main() {
    int opcion;
    
    do {
        cout << "\n MENU\n";
        cout << "1. Agregar producto\n2. Mostrar activos\n3. Mostrar por categoria\n";
        cout << "4. Buscar por codigo\n5. Modificar\n6. Eliminar\n";
        cout << "7. Cargar datos\n8. Guardar datos\n9. Salir\n";
        
        opcion = leerEntero("Opcion: ");
        
        switch (opcion) {
            case 1: agregarProducto(); break;
            case 2: mostrarProductosActivos(); break;
            case 3: mostrarPorCategoria(); break;
            case 4: buscarPorCodigo(); break;
            case 5: modificarProducto(); break;
            case 6: eliminarProducto(); break;
            case 7: cargarDatos(); break;
            case 8: guardarDatos(); break;
            case 9: cout << "Hasta la proxima!\n"; break;
            default: cout << "Opcion invalida.\n";
        }
    } while (opcion != 9);
    
    return 0;
}
